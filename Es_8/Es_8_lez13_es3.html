
<html>
		<head>
			<title> Es_8 lez13es3- Interactive 3D Graphics</title>
			<style>
			body {
				font-family: Monospace;
				background-color:#f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
		</style>
			<script src="libs/three.js"></script>
			<script src="libs/stats.min.js"></script>
			<script src="libs/OBJLoader.js"></script>
			<script src="libs/Coordinates.js"></script>
			<script src="libs/OrbitControls.js"></script>
		</head>
		-------------- Andrea Mansi UNIUD ---- Es_8 lez13es3
		<body>

<!-- shaders -->

		<script type="text/x-glsl" id="vertex">
			varying vec3 vNormal;
			varying vec3 vPosition;
		
			void main() {
				vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
				vPosition = vPos.xyz;
				vNormal = normalMatrix * normal;
				gl_Position = projectionMatrix * vPos;
			}
			</script>
			
		<script type="text/x-glsl" id="fragment">
			varying vec3 vNormal;
			varying vec3 vPosition;

			uniform vec3 pointLightPosition; // in world space
			uniform vec3 clight;

			uniform vec3 pointLightPosition2; // in world space
			uniform vec3 clight2;

			uniform vec3 cdiff;
			uniform float radius;
			const float PI = 3.14159;

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
				
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
				
				vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
				vec3 n2 = normalize( vNormal ); 
				
				float nDotl = max(dot( n, l ),0.0);
				float nDotl2 = max(dot( n2, l2 ),0.0);

				float dist = distance (vec4(0,0,0,1),lPosition);
				float dist2 = distance (vec4(0,0,0,1),lPosition2);

				float att = clamp(1.0 - dist/radius, 0.0, 1.0);
				float att2 = clamp(1.0 - dist2/radius, 0.0, 1.0);

				// formula would be:
				// outRadiance = clight *  PI * cdiff/PI * nDotl, the two PI cancel out
				vec3 outRadiance = ((clight*att * nDotl) + (clight2*att2 * nDotl2)) * cdiff;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
			</script>

			<script type="text/x-glsl" id="fragment_2">
				varying vec3 color;
				void main() {
					gl_FragColor = vec4(color, 1.0);
				}
			</script>

<!-- three.js -->
			<script>
				// VARIABLES //
			var scene, camera, renderer, camera, stats;
			var lightMesh, lightMesh2, uniforms;
			var radius = 60.0;
		
			function Start() {
			
				setupScene();
				setupCamera();
				setupRenderer();
				setupStatsOSD();
					
				// scene code here

				var lightParameters = {
				red: 1.0,
				green: 0.0075,
				blue: 0.0075,
				intensity: 1.2,
				}

				var lightParameters2 = {
				red: 0.0075,
				green: 1,
				blue: 0.15,
				intensity: 1.2,
				}
				var cdiff = {
					red: 0.5,
					green: 0.5,
					blue: 0.5,
				}

				uniforms = {
					cdiff:	{ type: "v3", value: new THREE.Vector3() },
					pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
					clight:	{ type: "v3", value: new THREE.Vector3() },
					pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },
					clight2:	{ type: "v3", value: new THREE.Vector3() },
					radius: {type: "float", value: radius},

				};

				vs = document.getElementById("vertex").textContent;
				fs = document.getElementById("fragment_2").textContent;

				ourMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
				geometry = new THREE.TorusKnotGeometry( 2, 0.5, 200, 32 );
				var mesh = new THREE.Mesh( geometry, ourMaterial );

				lightMesh = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16),
					new THREE.MeshBasicMaterial ({color: 0xffff00, wireframe:true}));
				lightMesh.position.set( 5.0,5.0,5.0 );
				uniforms.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,
				lightMesh.position.y,
				lightMesh.position.z);

				lightMesh2 = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16),
					new THREE.MeshBasicMaterial ({color: 0xffff00, wireframe:true}));
				lightMesh2.position.set( -5.0, -5.0, -5.0 );
				uniforms.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x,
				lightMesh2.position.y,
				lightMesh2.position.z);

				scene.add(mesh );
				scene.add(lightMesh);
				scene.add(lightMesh2);

				uniforms.cdiff.value = new THREE.Vector3(cdiff.red,cdiff.green,cdiff.blue);
				
				uniforms.clight.value = new THREE.Vector3(
				lightParameters.red * lightParameters.intensity,
				lightParameters.green * lightParameters.intensity,
				lightParameters.blue * lightParameters.intensity);

				uniforms.clight2.value = new THREE.Vector3(
				lightParameters2.red * lightParameters2.intensity,
				lightParameters2.green * lightParameters2.intensity,
				lightParameters2.blue * lightParameters2.intensity);
					
				}
				
				function Update() {	
					requestAnimationFrame(Update);
					stats.update();
					controls.update();
					renderer.render(scene, camera);

					lightMesh2.position.y += 0.025;
					lightMesh.position.y -= 0.025;

					uniforms.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x,
					lightMesh2.position.y,
					lightMesh2.position.z);

					uniforms.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,
					lightMesh.position.y,
					lightMesh.position.z);


				}
	
				function setupScene(){	// SCENE //
					scene = new THREE.Scene();
					Coordinates.drawAllAxes();
				}
	
				function setupCamera(){	 // CAMERA //
					camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
					camera.position.set(0,10,10);
					camera.lookAt( new THREE.Vector3(0,0,0));
					controls = new THREE.OrbitControls(camera);
				}
	
				function setupRenderer(){	// RENDERER //
					renderer = new THREE.WebGLRenderer({antialias:true});
					renderer.setSize( window.innerWidth, window.innerHeight );
					renderer.setClearColor(0xf0f0f0);
					renderer.shadowMap.Type = THREE.PCFShadowMap;
					document.body.appendChild( renderer.domElement);
					renderer.shadowMap.enabled = true;
					renderer.shadowMap.type = THREE.BasicShadowMap;
				}
	
				function setupStatsOSD(){	// STATISTICS OSD //
					stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.top = '0px';
					document.body.appendChild( stats.domElement );
				}
	
				function setupBasicLightSystem(){	// ADD A BASIC LIGHT SYSTEM TO THE SCENE //
					// basic ambient light
					light = new THREE.AmbientLight(0xffffff,0.23); 
					scene.add(light);
					// basic point light
					plight = new THREE.PointLight(0xffffff,2.9,21);
					plight.castShadow = true;
					plight.shadow.camera.near = 0.2;
					plight.shadow.camera.far = 25;
					scene.add(plight);
					plight.position.y = 65;
					plight.shadow.mapSize.width = 2048;
					plight.shadow.mapSize.height = 2048;
				}
	
				function spawnFloor(larghezza,altezza,profondità,pos_y){
					var geometry1 = new THREE.CubeGeometry(larghezza,altezza,profondità);
					var material1 = new THREE.MeshPhongMaterial( { color:0xffffff } );
					var floor = new THREE.Mesh( geometry1, material1 );
					floor.receiveShadow = true;
					scene.add(floor);
					floor.position.y = pos_y;
				}
	
				// Main code goes here
	
				Start();
				Update();
				
			</script>
		</body>
	</html>